package visual{	import com.adobe.serialization.json.*;	import event.AlertEvent;	import flash.display.*;	import flash.events.*;	import flash.filters.DropShadowFilter;	import flash.geom.Matrix;	import flash.net.*;	import flash.system.*;	import flash.utils.*;		/**	 * JSONVisualizer is a loader to load the JSON string from URL and also a decoder to decode the JSON string to corresponding Table and Links.	 */	public class JSONVisualizer extends Sprite {				// Event		public static const JSON_DECODE_COMPLETE:String = "JSON_DECODE_COMPLETE";				private static const _JSON_OBJECT_TYPE_INFO_:String = "__TYPE_INFO__";	// used by swfparser so far, as the name of the json object.				/**		 * The container to hold all generated Tables and manage the layout.		 */		public var container:LayoutContainer;				private var ul:URLLoader;		private var uploadURL:URLRequest;        private var file:FileReference;				private var _numOfObjects:int = 0, _numOfConnections:int = 0, _numOfTags:int = 0;				private var depth:int = 0; // traversed depth (index of colume[])				private var colume:Array;				private var _decodeStartTime:int, _decodeEndTime:int;				private var decodedObj:Object;				function JSONVisualizer() {			addEventListener(Event.ADDED_TO_STAGE, init);					}				private function init(e:Event):void {			opaqueBackground = parent.opaqueBackground;		}						/**		 * Select a local SWF file and upload it		 */		public function uploadSWF():void {			uploadURL = null;			uploadURL = new URLRequest(Global.config.system.uploadswf2jsonURL);						file = null;            file = new FileReference();			file.addEventListener(Event.SELECT, selectHandler);			file.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);            file.addEventListener(ProgressEvent.PROGRESS, progressHandler);			file.addEventListener(DataEvent.UPLOAD_COMPLETE_DATA, uploadCompleteDataHandler);						var swffilter:FileFilter = new FileFilter("Flash file (.swf)", "*.swf");						file.browse([swffilter]);		}				/**		 * Load a SWF URL, ask http://rintarou.dyndns.org/tests/swf2json.php to parse and return the JSON string.		 * @param	url URL of .swf file.		 */ 		public function loadURL(url:String = ""):void {			loadInit();						// To get SWF JSON data			var ur:URLRequest = new URLRequest(Global.config.system.swf2jsonURL + url );						ul = new URLLoader();			ul.addEventListener(Event.COMPLETE, onComplete);			ul.load(ur);					}				/**		 * Load JSON String and decode it		 * @param	json JSON string		 */		public function loadJSON(json:String):void {			if (json) {				loadInit();								decodeJSON(json);			}		}				/**		 * Return the number of JSON objects decoded.		 */		public function get numOfObjects():int {			return _numOfObjects;		}				/**		 * Return the number of links generated.		 */		public function get numOfConnections():int {			return _numOfConnections;		}				/**		 * Return the number of tags decoded.		 */		public function get numOfTags():int {			return _numOfTags;		}				/////////////////////////////////////////////////		/// Event Handlers		/////////////////////////////////////////////////				/**		 * Event Handler of uploaded SWF file.		 * @param	evt URLLoader upload complete event.		 */ 		private function uploadCompleteDataHandler(evt:DataEvent):void {			dispatchEvent(new AlertEvent(file.name + " is uploaded."));			loadJSON(evt.data);		}				/**		 * Event Handler of selected the swf file to be uploaded.		 * @param	evt tiggered after the local file is selected.		 */ 		private function selectHandler(evt:Event):void {			file.upload(uploadURL);		}				private function progressHandler(evt:ProgressEvent):void {			dispatchEvent(new AlertEvent("Uploading " + file.name + " : " + evt.bytesLoaded + "/" + evt.bytesTotal + " bytes"));        }				private function ioErrorHandler(evt:IOErrorEvent):void {            dispatchEvent(new AlertEvent(evt.text));        }		/**		 * Event Handler for LoadURL(), decode the returned JSON string		 */		private function onComplete(evt:Event):void {						decodeJSON(ul.data);		}						/////////////////////////////////////////////////		/// Internal Used Functions		/////////////////////////////////////////////////		private function loadInit():void {			if (container) {				removeChild(container);				container = null;				colume = null;				decodedObj = null;			}			System.gc();						_numOfObjects = 0;			_numOfConnections = 0;			_numOfTags = 0;			depth = 0;			colume = new Array();			container = new LayoutContainer();			container.scaleX = 0.7;			container.scaleY = 0.7;			addChild(container);		}				private function decodeJSON(json:String):void {			if (json) {				decodedObj = JSON.decode(json);				if ((decodedObj[_JSON_OBJECT_TYPE_INFO_] == ".swf") && decodedObj["Tags"]) {					_numOfTags = (decodedObj["Tags"] as Array).length;					Global.runtime.isSWF = true;				} else {					Global.runtime.isSWF = false;				}				colume[0] = new Vector.<Object>();				colume[0].push({anchor1: null, obj:decodedObj});				addEventListener(Event.ENTER_FRAME, onEnterFrame);				_decodeStartTime = getTimer();			}		}				private function onEnterFrame(e:Event):void {			var startTime:uint = getTimer();			while ((getTimer() - startTime) < 40) {				if (colume[depth]) {					/* decodeColume(depth) */					var list:Vector.<Object> = colume[depth];					if (list.length) {						// get element from list						var o:Object = list.shift();						var linkedTable:Table = traverse(o.obj);						if (o.anchor1) { // create Anchors and Paths							linkedTable.parentTable = o.anchor1.target;	// set the reference							// check the table.y							if (linkedTable.y < linkedTable.parentTable.y)								linkedTable.y = linkedTable.parentTable.y;							var anchor2:Anchor = new Anchor(linkedTable, linkedTable.leftMiddle);							var path:ConnPath = new ConnPath(o.anchor1, anchor2, o.anchor1.target.linkSetting);							container.addPath(path);							_numOfConnections ++;						}						dispatchEvent(new AlertEvent("Parsing object " + _numOfObjects));												} else {						depth++;					}									} else {					_decodeEndTime = getTimer();					removeEventListener(Event.ENTER_FRAME, onEnterFrame);					dispatchEvent(new AlertEvent(_numOfObjects + " Objects parsed in " + ((_decodeEndTime - _decodeStartTime)/1000) + "sec."));					dispatchEvent(new Event(JSON_DECODE_COMPLETE));										break;				}			}		}				private function createTable(header:String):Table {			_numOfObjects++;						var tableConfig:Object = Global.config.table;			switch(header) {				case "SHAPEWITHSTYLE":					return new Table(header, tableConfig.shapeWithStyle);					break;				case "SHAPE":					return new Table(header, tableConfig.shape);					break;				case "DefineShape":				case "DefineShape2":				case "DefineShape3":				case "DefineShape4":					return new Table(header, tableConfig.defineShape);					break;				case "Gradient Fill":				case "Solid Fill":				case "GRADIENT":				case "GRADRECORD":				case "FILLSTYLEARRAY":				case "LINESTYLEARRAY":				case "LINESTYLE":				case "LINESTYLE2":					return new Table(header, tableConfig.colors);				default:					return new Table(header);			}		}		/*		 * Traverse the decoded JSON object and create a corresponding Table to represent it.		 * 		 * @param obj The decoded JSON object		 */		private function traverse(obj:Object):Table {						if (!obj.__KEYARRAY__) // null object with any property				return null;						var table:Table;			var nextDepth:uint = depth + 1;						if (!colume[nextDepth]) { // create the list to hold child objects				colume[nextDepth] = new Vector.<Object>;			}						var childList:Vector.<Object> = colume[nextDepth];						if (obj[_JSON_OBJECT_TYPE_INFO_]) {				table = createTable(obj[_JSON_OBJECT_TYPE_INFO_]);			} else {				table = createTable("Object");	// Normal Object without type info			}						// Deal with SHAPEWITHSTYLE to create VShapeWithStyle:Shape for this table.			table.setJSON(obj, obj[_JSON_OBJECT_TYPE_INFO_]);						var key:String;			var value:*;						var valueCell:Cell;			var anchor:Anchor;									// Traverse properties (key, value) pair			for (var i:uint = 0; i < obj.__KEYARRAY__.length; i++) {				key = obj.__KEYARRAY__[i];								if (key == _JSON_OBJECT_TYPE_INFO_) {					continue;				}								value = obj[key];								// deal with value = obj[key]				if (typeof(value) == "object") {										if (value is Array) { // (1) value is an array												var element:*;						// deal with array values						for (var j:uint = 0; j < value.length; j++) {							element = value[j];														if (typeof(element) == "object") { // array value is an object								if (element[_JSON_OBJECT_TYPE_INFO_])									valueCell = table.appendRow(key + "[" + String(j) + "]", element[_JSON_OBJECT_TYPE_INFO_]);								else									valueCell = table.appendRow(key + "[" + String(j) + "]", "{}");																	if (!Global.runtime.showShapeRecord && (obj[_JSON_OBJECT_TYPE_INFO_] == "SHAPE") && (key == "ShapeRecords")) {									// skip shaperecords array								} else {									anchor = new Anchor(table, valueCell.rightMiddle, valueCell);									childList.push( { anchor1:anchor, obj:element } );								}							} else { // array value is primitive data								table.appendRow(key + "[" + String(j) + "]", String(element));							}						}											} else if (value is Object) { // (2) value is an object						if (value[_JSON_OBJECT_TYPE_INFO_])							valueCell = table.appendRow(key, value[_JSON_OBJECT_TYPE_INFO_]);						else							valueCell = table.appendRow(key, "{}");													anchor = new Anchor(table, valueCell.rightMiddle, valueCell);						childList.push({anchor1:anchor, obj:value});					}									} else { // (3) value is primitive data					table.appendRow(key, value);				}							}			container.addTable(table, depth);			return table;		}	}}