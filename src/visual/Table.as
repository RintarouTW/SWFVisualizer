package visual{	import flash.geom.Matrix;	import flash.geom.Point;	import flash.text.*;	import flash.display.*;	import flash.filters.*;	import flash.events.*;	import flash.ui.Keyboard;		import flash.external.ExternalInterface;		import com.greensock.*;	import com.greensock.easing.*;		import swf.*;		/**	 * Table contains two columes, the left colume contains name cells and the right colume contains value cells.	 * A table represent a JSON object in design and capable to generate the preview drawing result for different type of	 * data structure defined in SWF (such as Edge, Shape, Gradient, etc...).	 */	public class Table extends Sprite {				// Events		public static const TABLE_OVER:String 		= "TABLE_OVER";		public static const TABLE_OUT:String 		= "TABLE_OUT";		public static const SCALE_CHANGED:String 	= "SCALE_CHANGED";		public static const POSITION_CHANGED:String = "POSITION_CHANGED";		public static const WIDTH_CHANGED:String 	= "WIDTH_CHANGED";				public static const TRACK_BACK:String		= "TRACK_BACK";	// track back to the owner object		// filters		private static var shadowFilter:DropShadowFilter = new DropShadowFilter(5);		private static var glowFilter:GlowFilter = new GlowFilter(0xffffff);				// default style setting		private var _config:Object = Global.config.table.normal;				private var myHeader:Cell;				private var numRows:uint = 0;		private var _tableWidth:uint = 0;		private var previewBox:Shape = null;				private var jsonObj:Object = null;		private var type:String = null;						private var nameColume:Sprite = new Sprite();		private var valueColume:Sprite = new Sprite();				private var myParentTable:Table = null;	// reference to my parent table.				/**		 * @param	header    The label to indicate what type is this table(object).		 * @param	setting  used to override the default style setting.		 */		function Table(header:String, setting:Object = null) {						filters = [shadowFilter]; // drop shadow			cacheAsBitmap = true;						addEventListener(MouseEvent.ROLL_OVER, rOver, false);			addEventListener(MouseEvent.ROLL_OUT, rOut, false);			addEventListener(MouseEvent.CLICK, mClick);						if (setting) {				_config = setting;			}						myHeader = new Cell(header, _config.header);			addChild(myHeader);						_tableWidth = width + 5;									nameColume.cacheAsBitmap = true;			valueColume.cacheAsBitmap = true;			addChild(nameColume);			addChild(valueColume);			nameColume.y = myHeader.height;			valueColume.y = myHeader.height;						addEventListener(Event.ADDED_TO_STAGE, draw);		}				/**		 * Append a new row to this table with (name, value) pair.		 * @param	name	Name of this row.		 * @param	value   Value of this row.		 * @return The new value cell will be returned for anchor.		 */		public function appendRow(name:String, value:String):Cell {						if(1) {				var nameCell:Cell  = new Cell(name, _config.body);				var valueCell:Cell = new Cell(value, _config.body);								nameCell.y  = numRows * nameCell.height;				valueCell.y = numRows * valueCell.height;								nameColume.addChild(nameCell);							valueColume.x = nameColume.width;				valueColume.addChild(valueCell);								numRows++;								_tableWidth = width + 5;								return valueCell;			} else {				return myHeader;			}		}				/**		 * Bind the table to the corresponding JSON object.		 * @param	jsonObject	The JSON object represents a structure defined in SWF format.		 * @param	jsonType	Indicate which data type of this object defined in SWF format.		 */ 		public function setJSON(jsonObject:Object, jsonType:String):void {			jsonObj = jsonObject;			type = jsonType;		}				/**		 * Used by SWFVisualizer which handle all the keyboard event,		 * if left key pressed, will be treated as track back request and call this function		 * to send out track back event.		 */				public function dispatchTrackBackEvent():void {			dispatchEvent(new Event(TRACK_BACK));		}				public function set parentTable(table:Table):void {			myParentTable = table;		}				public function get parentTable():Table {			return myParentTable;		}				/**		 * Return the header text of this table.		 */		public function get header() : String {			return myHeader.text;		}				/**		 * Return left middle position of this table.		 */		public function get leftMiddle() : Object {			return { x : 0, y : (height >> 1)};		}				/**		 * Return the width of this table in pixels.		 */		public function get tableWidth() : uint {			return _tableWidth;		}				/**		 * Return the link style setting for ConnPath which need this information to draw the links.		 */		public function get linkSetting():Object {			return _config.link;		}				override public function set x(value:Number):void {			super.x = value;			dispatchEvent(new Event(POSITION_CHANGED));		}				override public function set y(value:Number):void {			super.y = value;			dispatchEvent(new Event(POSITION_CHANGED));		}				override public function set scaleY(value:Number):void {			super.scaleY = value;			dispatchEvent(new Event(SCALE_CHANGED));		}		override public function set scaleX(value:Number):void {			super.scaleX = value;			dispatchEvent(new Event(SCALE_CHANGED));		}				/**		 * Handler of Mouse Click event.		 * @param	e MouseEvent.CLICK event		 */		private function mClick(e:MouseEvent):void {			if ((type == "SHAPEWITHSTYLE") ||				(type == "DefineShape") ||				(type == "DefineShape2") ||				(type == "DefineShape3") ||				(type == "DefineShape4"))			{				if (previewBox && ExternalInterface.available) {					ExternalInterface.call("drawCanvas", VShapeWithStyle(previewBox).getCanvasStr(), previewBox.width, previewBox.height);				}			}			if (type == "SHAPE") {								if (previewBox) {					VShape(previewBox).progressiveDraw();				}			}		}				private function rOut(e:MouseEvent):void {						dispatchEvent(new Event(TABLE_OUT, true));			if (previewBox) {				removeChild(previewBox);				previewBox = null;			}						if (Global.runtime.mouseOverScaling) {				TweenLite.to(this, 1, { delay:1, scaleX:1, scaleY:1, ease:Elastic.easeOut, overwrite:5 } );			}					}				private function rOver(e:MouseEvent):void {						dispatchEvent(new Event(TABLE_OVER, true));						parent.setChildIndex(this, parent.numChildren - 1);						if (Global.runtime.isSWF) {				drawPreviewBox();			}						if (Global.runtime.mouseOverScaling) {				TweenLite.to(this, 0.8, { scaleX:1.5, scaleY:1.5, ease:Elastic.easeOut, overwrite:5 } );			}					}						private function drawPreviewBox():void {						// Define Tags			if ((type == "DefineShape") ||				(type == "DefineShape2") ||				(type == "DefineShape3") ||				(type == "DefineShape4"))			{				previewBox = new VShapeWithStyle(jsonObj["Shapes"]);				previewBox.filters = [glowFilter];			}						if (type == "SHAPEWITHSTYLE") {				previewBox = new VShapeWithStyle(jsonObj);				previewBox.filters = [glowFilter];			}						if (type == "SHAPE") {				previewBox = new VShape(jsonObj);							}						var colorInfo:ColorInfo			var startX:Number = 0, startY:Number = 0;			var edge:VEdge;			var matrix:Matrix;						if ((type == "LINESTYLE2") || 				(type == "LINESTYLE")) {									matrix = new Matrix();				matrix.createGradientBox(150, 50);								previewBox = new Shape();								VStyleUtil.lineStyle(jsonObj, previewBox.graphics, matrix);				previewBox.graphics.moveTo(0, 50);				previewBox.graphics.lineTo(50, 0);				previewBox.graphics.lineTo(100, 50);				previewBox.graphics.lineTo(150, 0);				previewBox.graphics.endFill();				previewBox.filters = [glowFilter];			}						if (type == "GRADRECORD") {				colorInfo = new ColorInfo(jsonObj["Color"]);								previewBox = new Shape();								if (colorInfo.hasAlpha) {					previewBox.graphics.beginFill(colorInfo.Color, colorInfo.Alpha);				} else {					previewBox.graphics.beginFill(colorInfo.Color);				}				previewBox.graphics.drawRect(0, 0, 50, 50);				previewBox.graphics.endFill();								previewBox.filters = [glowFilter];			}						if (type == "GRADIENT") {				previewBox = new Shape();								matrix = new Matrix();				matrix.createGradientBox(200, 80, 0, 0, 0);								/* use the faked linear fill style to draw the gradient */				var fillstyle:Object = { FillStyleType : 0x10, Gradient : jsonObj };								VStyleUtil.beginFill(fillstyle, previewBox.graphics, matrix);				previewBox.graphics.drawRect(0, 0, 200, 80);				previewBox.graphics.endFill();								previewBox.filters = [glowFilter];			}						if ((type == "Solid Fill") || 			    (type == "Gradient Fill")) {				previewBox = new Shape();								matrix = new Matrix();				matrix.createGradientBox(100, 100, 0, 0, 0);								VStyleUtil.beginFill(jsonObj, previewBox.graphics, matrix);				previewBox.graphics.drawRect(0, 0, 100, 100);				previewBox.graphics.endFill();								previewBox.filters = [glowFilter];			}									if (type == "SetBackgroundColor") {				previewBox = new Shape();								colorInfo = new ColorInfo(jsonObj["BackgroundColor"]);												previewBox.graphics.beginFill(colorInfo.Color);				previewBox.graphics.drawRect(0, 0, 50, 50);				previewBox.graphics.endFill();								previewBox.filters = [glowFilter];			}			if (type == "STRAIGHTEDGERECORD") {								// in twips				var deltaX:Number = 0, deltaY:Number = 0;												if (jsonObj["DeltaX"]) {					deltaX = jsonObj["DeltaX"];				}				if (jsonObj["DeltaY"]) {					deltaY = jsonObj["DeltaY"];				}												edge = new VEdge();				edge.asLine(0, 0, deltaX, deltaY);								previewBox = new Shape();				previewBox.graphics.lineStyle(1, 0xffffff);				edge.draw(previewBox.graphics, true);				edge.drawArrow(previewBox.graphics);				previewBox.graphics.endFill();							}						if (type == "CURVEDEDGERECORD") {				// in twips				var controlDeltaX:Number = 0, controlDeltaY:Number = 0, anchorDeltaX:Number = 0, anchorDeltaY:Number = 0;				var controlX:Number = 0, controlY:Number = 0, anchorX:Number = 0, anchorY:Number = 0;								controlDeltaX = jsonObj["ControlDeltaX"];				controlDeltaY = jsonObj["ControlDeltaY"];				anchorDeltaX  = jsonObj["AnchorDeltaX"];				anchorDeltaY  = jsonObj["AnchorDeltaY"];				controlX = startX + controlDeltaX;				controlY = startY + controlDeltaY;								anchorX = controlX + anchorDeltaX;				anchorY = controlY + anchorDeltaY;												edge = new VEdge();				edge.asCurve(0, 0, controlX, controlY, anchorX, anchorY);				previewBox = new Shape();								previewBox.graphics.lineStyle(1, 0xffffff);				edge.draw(previewBox.graphics, true);				edge.drawArrow(previewBox.graphics);								previewBox.graphics.endFill();			}						if (previewBox) {				// translate to the 1st quadrant (+,+)				previewBox.x -= previewBox.getBounds(previewBox).x;				previewBox.y -= previewBox.getBounds(previewBox).y;								addChild(previewBox);				previewBox.x += _tableWidth + 30;				previewBox.y += 5;				previewBox.visible = true;			}			}						private function draw(e:Event):void {	// this should be only called once.		    //trace(width, _tableWidth);			dispatchEvent(new Event(WIDTH_CHANGED));						var matrix:Matrix = new Matrix();			matrix.createGradientBox(_tableWidth, _config.header.height, Math.PI / 2);						var endColor:uint = _config.header.backgroundColor;			var startColor:uint = endColor + 0x323232;						// draw background			graphics.clear();			graphics.beginGradientFill(GradientType.LINEAR, [startColor, endColor], [1, 1], [0, 230], matrix);			graphics.drawRect(0, 0, _tableWidth, _config.header.height);						matrix.createGradientBox(_tableWidth, numRows * _config.header.height, Math.PI / 2);			startColor = _config.body.backgroundColor;			endColor = startColor - 0x101010;						graphics.beginGradientFill(GradientType.LINEAR, [startColor, endColor], [1, 1], [0, 255], matrix);			graphics.drawRect(0, _config.header.height, _tableWidth, numRows * _config.header.height);			graphics.endFill();								}			}}