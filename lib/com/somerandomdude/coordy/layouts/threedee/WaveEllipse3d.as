 /*The MIT LicenseCopyright (c) 2009 P.J. Onori (pj@somerandomdude.com)Permission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.*/  /** * * * @author      P.J. Onori * @version     0.1 * @description * @url  */package com.somerandomdude.coordy.layouts.threedee {	import com.somerandomdude.coordy.constants.LayoutType;	import com.somerandomdude.coordy.events.CoordyNodeEvent;	import com.somerandomdude.coordy.nodes.INode;	import com.somerandomdude.coordy.nodes.threedee.EllipseNode3d;	import com.somerandomdude.coordy.nodes.threedee.INode3d;	public class WaveEllipse3d extends Layout3d implements ILayout3d	{				private static const PI:Number=Math.PI;		private static const PI_180:Number=Math.PI/180;				private var _rotationY:Number;		private var _rotationZ:Number;				private var _frequencyX:Number=1;		private var _frequencyY:Number=1;		private var _frequencyZ:Number=1;				/**		 * Accessor for eccentricity property		 *		 * @return	eccentricity  Eccentricity of ellipse  		 */		public function get eccentricity():Number		{			var a:Number = (_width>_height) ? _width/2:_height/2;			var b:Number = (_width>_height) ? _height/2:_width/2;			var e:Number = Math.sqrt(1-(Math.pow(b,2)/Math.pow(a,2)));						return e;		}				/**		 * Mutator for frequency X property		 *		 * @param	value	   		 */		public function set frequencyX(value:Number):void		{			this._frequencyX=value;			this._updateFunction();		}				public function get frequencyX():Number { return this._frequencyX; }				/**		 * Mutator for frequency X property		 *		 * @param	value	   		 */		public function set frequencyY(value:Number):void		{			this._frequencyY=value;			this._updateFunction();		}				public function get frequencyY():Number { return this._frequencyY; }				/**		 * Mutator for frequency X property		 *		 * @param	value	   		 */		public function set frequencyZ(value:Number):void		{			this._frequencyZ=value;			this._updateFunction();		}				public function get frequencyZ():Number { return this._frequencyZ; }				/**		 * Mutator for rotation property		 *		 * @param	value	Global rotation position of layout organizer   		 */		public function set rotationX(value:Number):void		{			this._rotation=value;			this._updateFunction();		}				public function get rotationX():Number { return this._rotation; }				/**		 * Mutator for rotation property		 *		 * @param	value	Global rotation position of layout organizer   		 */		public function set rotationY(value:Number):void		{			this._rotationY=value;			this._updateFunction();		}				public function get rotationY():Number { return this._rotationY; }				/**		 * Mutator for rotation property		 *		 * @param	value	Global rotation position of layout organizer   		 */		public function set rotationZ(value:Number):void		{			this._rotationZ=value;			this._updateFunction();		}				public function get rotationZ():Number { return this._rotationZ; }				/**		 * Distributes nodes in a 3d wave-ellipse.		 * 		 * @param width				Width of the wave-ellipse		 * @param height			Height of the wave-ellipse		 * @param depth				Depth of the wave-ellipse		 * @param x					x position of the wave-ellipse		 * @param y					y position of the wave-ellipse		 * @param z					z position of the wave-ellipse		 * @param rotation			Rotation of the wave-ellipse along the x-axis		 * @param rotationY			Rotation of the wave-ellipse along the y-axis		 * @param rotationZ			Rotation of the wave-ellipse along the z-axis		 * @param jitterX			Jitter multiplier for the layout's nodes on the x axis		 * @param jitterY			Jitter multiplier for the layout's nodes on the y axis		 * @param jitterZ			Jitter multiplier for the layout's nodes on the z axis		 * 		 */				public function WaveEllipse3d(width:Number, 									height:Number, 									depth:Number, 									x:Number=0, 									y:Number=0, 									z:Number=0, 									rotation:Number=0, 									rotationY:Number=90, 									rotationZ:Number=90, 									jitterX:Number=0, 									jitterY:Number=0, 									jitterZ:Number=0):void		{				this._nodes = new Array();			this._width=width;			this._height=height;			this._depth=depth;			this._x=x;			this._y=y;			this._z=z;			this._jitterX=jitterX;			this._jitterY=jitterY;			this._jitterZ=jitterZ;			this._rotation=rotation;			this._rotationY=rotationY;			this._rotationZ=rotationZ;		}				/**		 * Returns the type of layout in a string format		 * 		 * @see com.somerandomdude.coordy.layouts.LayoutType		 * @return Layout's type		 * 		 */		override public function toString():String { return LayoutType.WAVE_ELLIPSE_3D; }				/**		 * Adds object to layout in next available position.		 *		 * @param  object  Object to add to layout		 * @param  moveToCoordinates  automatically move DisplayObject to corresponding nodes's coordinates		 * 		 * @return newly created node object containing a link to the object		 */		override public function addNode(object:Object=null, moveToCoordinates:Boolean=true):INode		{			if(object&&!validateObject(object)) throw new Error('Object does not implement at least one of the following properties: "x", "y", "z", "rotationX", "rotationY", "rotationZ"');			if(object&&linkExists(object)) return null;			var node:EllipseNode3d = new EllipseNode3d(object,0,0,0,0,Math.random()*((Math.random()>.5?1:-1)), Math.random()*((Math.random()>.5?1:-1)), Math.random()*((Math.random()>.5?1:-1)));			this.storeNode(node);						this.update();						if(object&&moveToCoordinates) this.render();						dispatchEvent(new CoordyNodeEvent(CoordyNodeEvent.ADD, node));						return node;		}						/**		 * Adds object to layout in next available position <strong>This method is depreceated.</strong>		 *		 * @param  object  Object to add to layout		 * @param  moveToCoordinates  automatically move DisplayObject to corresponding node's coordinates		 * 		 * @return newly created node object containing a link to the object		 */		override public function addToLayout(object:Object,  moveToCoordinates:Boolean=true):INode		{			if(!validateObject(object)) throw new Error('Object does not implement at least one of the following properties: "x", "y", "z", "rotationX", "rotationY", "rotationZ"');			if(linkExists(object)) return null;			var node:EllipseNode3d = new EllipseNode3d(object,0,0,0,0,Math.random()*((Math.random()>.5?1:-1)), Math.random()*((Math.random()>.5?1:-1)), Math.random()*((Math.random()>.5?1:-1)));			this.storeNode(node);						this.update();						if(moveToCoordinates) this.render();						dispatchEvent(new CoordyNodeEvent(CoordyNodeEvent.ADD, node));						return node;		}				/**		 * Returns angle of position of specified cell in degrees 		 *		 * @param  cell  cell object		 */		public function getCellAngle(cell:INode3d):Number		{			var xR:Number = cell.link.x-(_x+_width/2);			var yR:Number = cell.link.y-(_y+_height/2);						var rads:Number = Math.atan2(yR*(_width/_height), xR);			var a:Number = rads*(180/PI)+90;						return a;		}				/**		 * Sets angle of position of specified cell in degrees 		 *		 * @param  cell  cell object		 * @param  angle angle of cell in degrees		 */		public function setCellAngle(cell:INode3d, angle:Number):void		{			var nAngle:Number = getCellAngle(cell);			this.rotation=this.rotation-angle-nAngle;		}				/**		* Clones the current object's properties (does not include links to DisplayObjects)		* 		* @return WaveEllipse3d clone of object		*/		override public function clone():ILayout3d		{			var we3d:WaveEllipse3d = new WaveEllipse3d(_width, _height, _depth, _x, _y, _z, _rotation, _rotationY, _rotationZ, _jitterX, _jitterY, _jitterZ);					we3d.frequencyX=this._frequencyX;			we3d.frequencyY=this._frequencyY;			we3d.frequencyZ=this._frequencyZ;						return we3d;		}				/**		 * Updates the nodes' virtual coordinates. <strong>Note</strong> - this method does not update		 * the actual objects linked to the layout.		 * 		 */				override public function update():void		{			var w:Number = this._width/2;			var h:Number = this._height/2;			var rOffset:Number = _rotation*(PI_180);			var rad:Number;			var c:EllipseNode3d;						_depth=0;						var rY:Number = this._rotationY*(PI/180);			var rZ:Number = this._rotationZ*(PI/180);						for(var i:int=0; i<this._size; i++)			{									c = this._nodes[i];				rad = ((PI*(i))/(this._size/2))+rOffset;								c.x = (Math.sin(rZ)*(w*Math.cos(rad*this._frequencyX)))+(_x)+(c.jitterX*this._jitterX);				c.y= (Math.cos(rY)*(h*Math.sin(rad*this._frequencyY)))-(Math.cos(rZ)*(h*Math.cos(rad)))+(this._y)+(c.jitterY*this._jitterY);				c.z=  (Math.sin(rY)*(h*Math.sin(rad*this._frequencyZ))+(_z))+(c.jitterZ*this._jitterZ);							}		}					/**		 * Moves all elements along the eliptical path so that the specified cell is at the top of the ellipse		 *		 * @private		 * @param  cell  cell object to move		 */		public function rotateCellToTop(cell:INode3d):Number		{			var xR:Number = cell.link.x-(_x+_width/2);			var yR:Number = cell.link.y-(_y+_height/2);						var rads:Number = Math.atan2(yR*(_width/_height), xR);			//rotation of individual object			var a:Number = rads*(180/PI)+90;						this.rotation=rotation-a;			return a;		}	}}