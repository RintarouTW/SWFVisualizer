 /*The MIT LicenseCopyright (c) 2009 P.J. Onori (pj@somerandomdude.com)Permission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.*/  /** * * * @author      P.J. Onori * @version     0.1 * @description * @url  */ package com.somerandomdude.coordy.layouts.threedee {	import com.somerandomdude.coordy.constants.LayoutType;	import com.somerandomdude.coordy.events.CoordyNodeEvent;	import com.somerandomdude.coordy.nodes.INode;	import com.somerandomdude.coordy.nodes.threedee.EllipseNode3d;	import com.somerandomdude.coordy.nodes.threedee.INode3d;	public class Ellipse3d extends Layout3d implements ILayout3d	{		public static const UPDATE_FAST:String="updateFast";		public static const UPDATE_ACCURATE:String="updateAccurate";				private static const PI:Number=Math.PI;		private static const PI_180:Number=PI/180;				private var _rotationY:Number;		private var _rotationZ:Number;				private var _updateType:String;				/**		 * Serves same function as <em>height</em> property		 * 		 * @see #height		 * 		 * @return z-dimension		 * 		 */					override public function get depth():Number { return _height; }		override public function set depth(value:Number):void 		{			_height=value;			_updateFunction();		}				/**		 * 		 * @return 		 * 		 */				public function get updateType():String { return this._updateType; }			public function set updateType(value:String):void		{			this._updateType=value;		}				/**		 * Accessor for eccentricity property		 *		 * @return eccentricity Eccentricity of ellipse  		 */		public function get eccentricity():Number		{			var a:Number = (_width>_height) ? _width/2:_height/2;			var b:Number = (_width>_height) ? _height/2:_width/2;			var e:Number = Math.sqrt(1-(Math.pow(b,2)/Math.pow(a,2)));						return e;		}				/**		 * Mutator/accessor for rotation of the layout along the x-axis. This property mirrors the <em>rotationX</em> property		 * 		 * @see #rotationX		 *		 * @return value Rotation along the x-axis (in degrees)   		 */		override public function get rotation():Number { return this._rotation; } 		override public function set rotation(value:Number):void		{			this._rotation=value;			this._updateFunction();		}				/**		 * Mutator/accessor for rotation of the layout along the x-axis. This property mirrors the <em>rotation</em> property		 * 		 * @see #rotation		 *		 * @return value Rotation along the x-axis (in degrees)   		 */		public function get rotationX():Number { return this._rotation; } 		public function set rotationX(value:Number):void		{			this._rotation=value;			this._updateFunction();		}				/**		 * Mutator/accessor for rotation of the layout along the y-axis.		 *		 * @return value Rotation along the y-axis (in degrees)   		 */		public function get rotationY():Number { return this._rotationY; }		public function set rotationY(value:Number):void		{			this._rotationY=value;			this._updateFunction();		}				/**		 * Mutator/accessor for rotation of the layout along the z-axis.		 *		 * @return value Rotation along the z-axis (in degrees)   		 */		public function get rotationZ():Number { return this._rotationZ; }		public function set rotationZ(value:Number):void		{			this._rotationZ=value;			this._updateFunction();		}						/**		 * Distributes nodes in a 3d ellipse.		 * 		 * @param width 		Width of the ellipse		 * @param height 		Height of the ellipse		 * @param x 			x position of the ellipse		 * @param y 			y position of the ellipse		 * @param z 			z position of the ellipse		 * @param rotation 		Rotation of the ellipse along the x-axis		 * @param rotationY 	Rotation of the ellipse along the y-axis		 * @param rotationZ 	Rotation of the ellipse along the z-axis		 * @param jitterX		Jitter multiplier for the layout's nodes on the x axis 		 * @param jitterY		Jitter multiplier for the layout's nodes on the y axis		 * @param jitterZ		Jitter multiplier for the layout's nodes on the z axis		 * 		 */				public function Ellipse3d(width:Number, 								height:Number, 								x:Number=0, 								y:Number=0, 								z:Number=0, 								rotation:Number=0, 								rotationY:Number=0, 								rotationZ:Number=0, 								jitterX:Number=0, 								jitterY:Number=0, 								jitterZ:Number=0):void		{						this._width=width;			this._height=height;			this._x=x;			this._y=y;			this._z=z;			this._jitterX=jitterX;			this._jitterY=jitterY;			this._jitterZ=jitterZ;			this._rotation=rotation;			this._rotationY=rotationY;			this._rotationZ=rotationZ;			this._updateType=UPDATE_ACCURATE;					}				/**		 * Returns the type of layout in a string format		 * 		 * @see com.somerandomdude.coordy.layouts.LayoutType		 * @return Layout's type		 * 		 */				override public function toString():String { return LayoutType.ELLIPSE_3D; }				/**		 * Adds object to layout in next available position.		 *		 * @param  object  Object to add to layout		 * @param  moveToCoordinates  automatically move DisplayObject to corresponding nodes's coordinates		 * 		 * @return newly created node object containing a link to the object		 */		override public function addNode(object:Object=null, moveToCoordinates:Boolean=true):INode		{			if(object&&!validateObject(object)) throw new Error('Object does not implement at least one of the following properties: "x", "y", "z", "rotationX", "rotationY", "rotationZ"');			if(object&&linkExists(object)) return null;			var node:EllipseNode3d = new EllipseNode3d(object,0,0,0,0,0,0,Math.random()*((Math.random()>.5?1:-1)), Math.random()*((Math.random()>.5?1:-1)), Math.random()*((Math.random()>.5?1:-1)));			this.storeNode(node);						this.update();						if(object&&moveToCoordinates) render();						dispatchEvent(new CoordyNodeEvent(CoordyNodeEvent.ADD, node));						return node;		}				/**		 * Adds object to layout in next available position. <strong>This method is depreceated.</strong>		 *		 * @param  object  Object to add to layout		 * @param  moveToCoordinates  automatically move DisplayObject to corresponding nodes's coordinates		 * 		 * @return newly created node object containing a link to the object		 */		override public function addToLayout(object:Object,  moveToCoordinates:Boolean=true):INode		{			if(!validateObject(object)) throw new Error('Object does not implement at least one of the following properties: "x", "y", "z", "rotationX", "rotationY", "rotationZ"');			if(linkExists(object)) return null;			var node:EllipseNode3d = new EllipseNode3d(object,0,0,0,0,0,0,Math.random()*((Math.random()>.5?1:-1)), Math.random()*((Math.random()>.5?1:-1)), Math.random()*((Math.random()>.5?1:-1)));			this.storeNode(node as EllipseNode3d);						this.update();						if(moveToCoordinates) this.render();						dispatchEvent(new CoordyNodeEvent(CoordyNodeEvent.ADD, node));						return node;		}				/**		 * Returns angle of position of specified cell in degrees 		 *		 * @param  cell  cell object		 */		public function getNodeAngle(node:INode3d):Number		{			var xR:Number = node.link.x-(_x+_width/2);			var yR:Number = node.link.y-(_y+_height/2);						var rads:Number = Math.atan2(yR*(_width/_height), xR);			var a:Number = rads*(180/PI)+90;						return a;		}				/**		 * Sets angle of position of specified cell in degrees 		 *		 * @param  cell  cell object		 * @param  angle angle of cell in degrees		 */		public function setNodeAngle(node:INode3d):void		{			var angle:Number = getNodeAngle(node);			this.rotation=this.rotation-angle;		}				/**		* Clones the current object's properties (does not include links to DisplayObjects)		* 		* @return Ellipse3d clone of object		*/		override public function clone():ILayout3d		{			return new Ellipse3d(_width, _height, _x, _y, _z, _rotation, _rotationY, _rotationZ, _jitterX, _jitterY, _jitterZ);		}				/**		 * Updates the nodes' virtual coordinates. <strong>Note</strong> - this method does not update		 * the actual objects linked to the layout.		 * 		 * The Ellipse3d layout updates differently based on the value set in the <em>updateType</em> property		 * 		 * @see #updateType		 * 		 */				override public function update():void		{			(this._updateType==UPDATE_ACCURATE)?update_accurate():update_fast();		}				/**		* @private		*/		private function update_fast():void		{			var len:int=this._size;			var rOffset:Number = _rotation*PI_180;			var halfLen:Number=len >> 1;			var w:Number = this._width/2;			var h:Number = this._height/2;			var rad:Number;			var c:EllipseNode3d;			var i:int=0;						_depth=0;						var rZ:Number=_rotationZ*PI_180;			var rY:Number=_rotationY*PI_180;			var rZ2:Number=rZ + 1.57079632;			var rY2:Number=rY + 1.57079632;						var sRZ:Number;			var sRY:Number;						var cRZ:Number;			var cRY:Number;			var cRad:Number;			var sRad:Number;						//rotZ			if (rZ > 6.28318531 || rZ < -6.28318531) rad = (rZ % 6.28318531);		    if (rZ < -3.14159265)  rZ += 6.28318531;		    else if (rZ > 3.14159265)  rZ -= 6.28318531;						if (rZ < 0) sRZ = 1.27323954 * rZ + .405284735 * rZ * rZ;			else  sRZ = 1.27323954 * rZ - 0.405284735 * rZ * rZ;			if (rZ2 >  3.14159265) rZ2 -= 6.28318531;			if (rZ2 < 0) cRZ = 1.27323954 * rZ2 + 0.405284735 * rZ2 * rZ2;			else cRZ = 1.27323954 * rZ2 - 0.405284735 * rZ2 * rZ2;						//rotY			if (rY > 6.28318531 || rY < -6.28318531) rY = (rY % 6.28318531);		    if (rY < -3.14159265)  rY += 6.28318531;		    else if (rY > 3.14159265)  rY -= 6.28318531;						if (rY < 0) sRY = 1.27323954 * rY + .405284735 * rY * rY;			else  sRY = 1.27323954 * rY - 0.405284735 * rY * rY;			if (rY2 >  3.14159265) rY2 -= 6.28318531;			if (rY2 < 0) cRY = 1.27323954 * rY2 + 0.405284735 * rY2 * rY2;			else cRY = 1.27323954 * rY2 - 0.405284735 * rY2 * rY2;						for(i=0; i<len; i++)			{					c = this._nodes[i] as EllipseNode3d;				rad = ((PI*(i))/(halfLen))+rOffset;								if (rad > 6.28318531 || rad < -6.28318531) rad = (rad % 6.28318531);			    if (rad < -3.14159265)  rad += 6.28318531;			    else if (rad > 3.14159265)  rad -= 6.28318531;								if (rad < 0) sRad = 1.27323954 * rad + .405284735 * rad * rad;				else  sRad = 1.27323954 * rad - 0.405284735 * rad * rad;			    rad += 1.57079632;				if (rad >  3.14159265) rad -= 6.28318531;				if (rad < 0) cRad = 1.27323954 * rad + 0.405284735 * rad * rad;				else cRad = 1.27323954 * rad - 0.405284735 * rad * rad;													c.x = (sRZ*(w*cRad))+(_x)+(c.jitterX*this._jitterX);				c.y= (cRY*(h*sRad))-(cRZ*(h*cRad))+(_y)+(c.jitterY*this._jitterY);				c.z=  (sRY*(h*sRad)+(_z))+(c.jitterZ*this._jitterZ);							}		}				/**		* @private		*/		private function update_accurate():void		{			var len:int=this._size;			var w:Number = this._width/2;			var h:Number = this._height/2;			var rOffset:Number = _rotation*(PI/180);			var rad:Number;			var c:EllipseNode3d;						_depth=0;						var rY:Number = (90+this._rotationY)*(PI/180);			var rZ:Number = (90+this._rotationZ)*(PI/180);						for(var i:int=0; i<len; i++)			{									c = this._nodes[i];				rad = ((PI*(i))/(len/2))+rOffset;								c.x= (Math.sin(rZ)*(w*Math.cos(rad)))+(_x)+(c.jitterX*this._jitterX);				c.y= (Math.cos(rY)*(h*Math.sin(rad)))-(Math.cos(rZ)*(h*Math.cos(rad)))+(this._y)+(c.jitterY*this._jitterY);				c.z= (Math.sin(rY)*(h*Math.sin(rad))+(_z))+(c.jitterZ*this._jitterZ);								//need to add option to register ellipse layout at center... 							}		}						/**		 *		 * @private		 */		public function rotateCellToTop(cell:INode3d):Number		{			var xR:Number = cell.link.x-(_x+_width/2);			var yR:Number = cell.link.y-(_y+_height/2);						var rads:Number = Math.atan2(yR*(_width/_height), xR);			//rotation of individual object			var a:Number = rads*(180/PI)+90;						this.rotation=rotation-a;			return a;		}	}}